<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.codehilite {background-color:#fff;color:#333333;}
.codehilite .hll {background-color:#ffffcc;}
.codehilite .c{color:#999988;font-style:italic}
.codehilite .err{color:#a61717;background-color:#e3d2d2}
.codehilite .k{font-weight:bold}
.codehilite .o{font-weight:bold}
.codehilite .cm{color:#999988;font-style:italic}
.codehilite .cp{color:#999999;font-weight:bold}
.codehilite .c1{color:#999988;font-style:italic}
.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}
.codehilite .gd{color:#000000;background-color:#ffdddd}
.codehilite .ge{font-style:italic}
.codehilite .gr{color:#aa0000}
.codehilite .gh{color:#999999}
.codehilite .gi{color:#000000;background-color:#ddffdd}
.codehilite .go{color:#888888}
.codehilite .gp{color:#555555}
.codehilite .gs{font-weight:bold}
.codehilite .gu{color:#800080;font-weight:bold}
.codehilite .gt{color:#aa0000}
.codehilite .kc{font-weight:bold}
.codehilite .kd{font-weight:bold}
.codehilite .kn{font-weight:bold}
.codehilite .kp{font-weight:bold}
.codehilite .kr{font-weight:bold}
.codehilite .kt{color:#445588;font-weight:bold}
.codehilite .m{color:#009999}
.codehilite .s{color:#dd1144}
.codehilite .n{color:#333333}
.codehilite .na{color:teal}
.codehilite .nb{color:#0086b3}
.codehilite .nc{color:#445588;font-weight:bold}
.codehilite .no{color:teal}
.codehilite .ni{color:purple}
.codehilite .ne{color:#990000;font-weight:bold}
.codehilite .nf{color:#990000;font-weight:bold}
.codehilite .nn{color:#555555}
.codehilite .nt{color:navy}
.codehilite .nv{color:teal}
.codehilite .ow{font-weight:bold}
.codehilite .w{color:#bbbbbb}
.codehilite .mf{color:#009999}
.codehilite .mh{color:#009999}
.codehilite .mi{color:#009999}
.codehilite .mo{color:#009999}
.codehilite .sb{color:#dd1144}
.codehilite .sc{color:#dd1144}
.codehilite .sd{color:#dd1144}
.codehilite .s2{color:#dd1144}
.codehilite .se{color:#dd1144}
.codehilite .sh{color:#dd1144}
.codehilite .si{color:#dd1144}
.codehilite .sx{color:#dd1144}
.codehilite .sr{color:#009926}
.codehilite .s1{color:#dd1144}
.codehilite .ss{color:#990073}
.codehilite .bp{color:#999999}
.codehilite .vc{color:teal}
.codehilite .vg{color:teal}
.codehilite .vi{color:teal}
.codehilite .il{color:#009999}
.codehilite .gc{color:#999;background-color:#EAF2F5}
</style><title>README</title></head><body><article class="markdown-body"><h1 id="welcome-to-the-typing_json-library">Welcome to the <code>typing_json</code> library<a class="headerlink" href="#welcome-to-the-typing_json-library" title="Permanent link"></a></h1>
<p>The <code>typing_json</code> library offers type-aware JSON encoding and decoding functionalities, on top of those offered by the builtin <code>json</code> library. The functions <code>dump</code>, <code>dumps</code>, <code>load</code> and <code>loads</code> mirror the functionality of their <code>json</code> counterparts, adding type-aware encoding/decoding and runtime type-checking of decoded objects.</p>
<p>Supported types include JSON basic types, <code>Decimal</code>, typed collections from the <code>typing</code> library, literal types, union types, optional types and typed namedtuples. For a full list of types, see below.
The function <code>is_instance</code> extends the functionality of the builtin <code>isinstance</code> to include all the additional types supported by this library.</p>
<p>The <a href="https://sg495.github.io/typing-json/typing_json/index.html">documentation</a> for this library was generated with <a href="https://pdoc3.github.io/pdoc/">pdoc</a>.</p>
<h2 id="main-goals">Main goals<a class="headerlink" href="#main-goals" title="Permanent link"></a></h2>
<p>There are two main drivers behind the development of the <code>typing_json</code> library:</p>
<ol>
<li>Type-aware <strong>serialisation</strong> of data using JSON.</li>
<li>Runtime <strong>validation</strong> of JSON data for use with static typing.</li>
</ol>
<p>The first goal of the <code>typing_json</code> library is to automate the serialisation of statically typed data in Python.
In a statically typed Python application (e.g. one validated using <a href="http://mypy-lang.org/">mypy</a>), data is often structured using simple static types.
The <code>typing_json</code> library uses these types to automate the process of JSON serialisation and de-serialisation, ensuring that the serialised data can subsequently be de-serialised into a valid instance of the original static type, equivalent to the instance that was originally serialised.</p>
<p>The second goal of the <code>typing_json</code> library is to automate the validation of JSON data against existing static types.
When JSON data is loaded dynamically into a statically typed Python application, it needs to be validated to ensure that it conforms to whatever static types are being used as its specification.
The <code>typing_json</code> library uses these types to automate the validation process, i.e. to perform runtime type-checking of the JSON data against the static types.
This guarantees that data successfully de-serialised from JSON using the <code>load</code>/<code>loads</code> functions of the <code>typing_json</code> library conforms to the static type provided.</p>
<h2 id="types-supported">Types supported<a class="headerlink" href="#types-supported" title="Permanent link"></a></h2>
<p>The following types are currently supported by the <code>typing_json</code> library:</p>
<ul>
<li>the JSON basic types <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code> and <code>NoneType</code> (technically <code>type(None)</code>, but <code>None</code> can be used as an alias);</li>
<li>the type <code>Decimal</code> from the <code>decimal</code> builtin (cf. below for the handling of numerical types);</li>
<li>the following typed collections from the <code>typing</code> builtin library, as long as all generic type arguments are themselves supported: <code>List</code>, <code>Tuple</code>, <code>Deque</code>, <code>Set</code>, <code>FrozenSet</code>;</li>
<li>typed namedtuples constructed using <code>NamedTuple</code> from the builtin <code>typing</code> library, as long as all fields are of supported type;</li>
<li>the following typed collections from the <code>typing</code> builtin library, as long as the generic key/value generic type arguments are themselves supported: <code>Dict</code>, <code>Mapping</code> and <code>OrderedDict</code> (see below for additional requirements on the key generic type arguments and special behaviour on JSON encoding/decoding of keys);</li>
<li>enumeration types</li>
<li>the <code>Literal</code> types from the <code>typing_extensions</code> library, as long as all literal are of one of the JSON basic types above;</li>
<li><code>Optional</code> and <code>Union</code> types from the <code>typing</code> builtin library, as long as all generic type arguments are themselves supported (cf. below for a caveat about <code>Union</code> types).</li>
</ul>
<p>The following function can be used at runtime to check whether <code>t</code> is a type supported by the <code>typing_json</code> library:</p>
<div class="codehilite"><pre>    <span class="k">def</span> <span class="nf">is_json_encodable</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">failure_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>

<p>The optional parameter <code>failure_callback</code> can be used to pass a <code>Callable[[str], None]</code> that will be used to log any error messages.
The following provides an example of usage:</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">is_json_encodable</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">error_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">error_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_json_encodable</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">failure_callback</span><span class="o">=</span><span class="n">my_callback</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">error_log</span>
<span class="p">[</span><span class="s">&#39;Type typing.Set[int] is not keyable.&#39;</span><span class="p">,</span>
 <span class="s">&#39;Type of keys in typing.Dict[typing.Set[int], int] is not keyable.&#39;</span><span class="p">,</span>
 <span class="s">&#39;Type of elements in typing.List[typing.Dict[typing.Set[int], int]] is not json-encodable.&#39;</span><span class="p">]</span>
</pre></div>

<h2 id="overview-of-encodingdecoding-functions">Overview of encoding/decoding functions<a class="headerlink" href="#overview-of-encodingdecoding-functions" title="Permanent link"></a></h2>
<p>There are three pairs of encoding/decoding functions offered by the <code>typing_json</code> library, for use in three different circumstances.</p>
<p>The functions <code>to_json_obj</code> / <code>from_json_obj</code> offer runtime conversion of instances of supported types to/from JSON objects.</p>
<div class="codehilite"><pre>    <span class="k">def</span> <span class="nf">to_json_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">from_json_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>

<p>The functions <code>dumps</code> / <code>loads</code> offer (de-)serialisation of instances of supported types to/from JSON formatted strings.</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">encoded_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">decoded_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>

<p>The functions <code>dump</code> / <code>load</code> offer (de-)serialisation of instances of supported types to/from JSON formatted IO streams.</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">encoded_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">decoded_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>

<p>The calls <code>dump(obj, t, fp)</code> / <code>dumps(obj, t)</code> first use <code>to_json_obj(obj, t)</code> to encode an instance <code>obj</code> of a supported type <code>t</code> into a JSON object <code>obj_json</code>, then call <code>json.dump(obj_json)</code> / <code>json.dumps(obj_json)</code> to serialise <code>obj_json</code> to a file object <code>fp</code> or string.</p>
<p>Conversely, the calls <code>load(fp, t)</code> / <code>loads(s, t)</code> first call <code>json.load(fp)</code> / <code>json.loads(s)</code> to deserialise a JSON object <code>obj_json</code> from a file object <code>fp</code> or string <code>s</code>, then call <code>from_json_obj(obj_json, t)</code> to decode an instance <code>obj</code> of a supported type <code>t</code> from <code>obj_json</code>.</p>
<p>In all functions above, <code>TypeError</code> is raised if the object passed does not match the type specified.
This runtime type-checking is performed by the function <code>is_instance</code>:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">is_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">failure_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>

<p>The function <code>is_instance</code> extends the behaviour of the builtin <code>isinstance</code> to type-checking of instances <code>obj</code> of all types <code>t</code> supported by the <code>typing_json</code> library.
Most importantly, this includes the generic typed collections of the <code>typing</code> library, and features a slight alteration of behaviour on booleans and numerical types.</p>
<h2 id="using-dump-dumps-load-and-loads">Using <code>dump</code>, <code>dumps</code>, <code>load</code> and <code>loads</code><a class="headerlink" href="#using-dump-dumps-load-and-loads" title="Permanent link"></a></h2>
<p>The functions <code>dump</code>, <code>dumps</code>, <code>load</code> and <code>loads</code> in the <code>typing_json</code> library mirror their builtin <code>json</code> counterparts, with a couple of exceptions:</p>
<ul>
<li>an additional parameter <code>encoded_type</code> (resp. <code>decoded_type</code>) is used in <code>dump</code> / <code>dumps</code> (resp. in <code>load</code> / <code>loads</code>) to specify the type to be used in the JSON encoding (resp. decoding);</li>
<li>an additional optional parameter <code>cast_decimal</code> (default: <code>True</code>) is used in <code>load</code> / <code>loads</code> to specify whether instances of <code>Decimal</code> (used by default to parse float literals) should be silently cast to <code>int</code> and <code>float</code> wherever the type requires them to.</li>
</ul>
<p>Aside from the additional type parameter, the usage of <code>dump</code>, <code>dumps</code>, <code>load</code> and <code>loads</code> is the same as that of their <code>json</code> counterparts:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">load</span>
<span class="c1"># myexpenses.json:</span>
<span class="c1">#</span>
<span class="c1"># {</span>
<span class="c1">#   &quot;home&quot;: 150.25,</span>
<span class="c1">#   &quot;travel&quot;: 78.90,</span>
<span class="c1">#   &quot;entertainment&quot;: 52.00</span>
<span class="c1"># }</span>
<span class="c1">#</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;myexpenses.json&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="o">...</span>
<span class="p">{</span><span class="s">&quot;home&quot;</span><span class="p">:</span> <span class="mf">150.25</span><span class="p">,</span> <span class="s">&quot;travel&quot;</span><span class="p">:</span> <span class="mf">78.90</span><span class="p">,</span> <span class="s">&quot;entertainment&quot;</span><span class="p">:</span> <span class="mf">52.00</span><span class="p">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;{&quot;home&quot;: 150.25, &quot;travel&quot;: 78.9, &quot;entertainment&quot;: 52.0}&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="p">{</span><span class="s">&quot;home&quot;</span><span class="p">:</span> <span class="mf">150.25</span><span class="p">,</span> <span class="s">&quot;travel&quot;</span><span class="p">:</span> <span class="mf">78.90</span><span class="p">,</span> <span class="s">&quot;entertainment&quot;</span><span class="p">:</span> <span class="mf">52.00</span><span class="p">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">dump</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">myexpenses</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;home&quot;</span><span class="p">:</span> <span class="mf">150.25</span><span class="p">,</span> <span class="s">&quot;travel&quot;</span><span class="p">:</span> <span class="mf">78.90</span><span class="p">,</span> <span class="s">&quot;entertainment&quot;</span><span class="p">:</span> <span class="mf">52.00</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;myexpenses.json&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="o">...</span>      <span class="n">dump</span><span class="p">(</span><span class="n">myexpenses</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">fp</span><span class="p">)</span>
<span class="o">...</span>
<span class="c1"># myexpenses.json:</span>
<span class="c1">#</span>
<span class="c1"># {</span>
<span class="c1">#   &quot;home&quot;: 150.25,</span>
<span class="c1">#   &quot;travel&quot;: 78.90,</span>
<span class="c1">#   &quot;entertainment&quot;: 52.00</span>
<span class="c1"># }</span>
<span class="c1">#</span>
</pre></div>

<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">myexpenses</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;home&quot;</span><span class="p">:</span> <span class="mf">150.25</span><span class="p">,</span> <span class="s">&quot;travel&quot;</span><span class="p">:</span> <span class="mf">78.90</span><span class="p">,</span> <span class="s">&quot;entertainment&quot;</span><span class="p">:</span> <span class="mf">52.00</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">(</span><span class="n">myexpenses</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="s">&#39;{&quot;home&quot;: 150.25, &quot;travel&quot;: 78.9, &quot;entertainment&quot;: 52.0}&#39;</span>
</pre></div>

<h2 id="basic-types">Basic types<a class="headerlink" href="#basic-types" title="Permanent link"></a></h2>
<p>On JSON basic types, the <code>to_json_obj</code> and <code>from_json_obj</code> functions return their argument unchanged:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="mf">1.5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="s">&quot;hello&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
<span class="bp">None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># `None` is alias for `type(None)`</span>
<span class="bp">None</span>
</pre></div>

<p>The exact same outcomes above are obtained if <code>to_json_obj</code> is replaced with <code>from_json_obj</code>.</p>
<p>The behaviour of <code>is_instance</code> on JSON basic types features two slight alterations from the behaviour of the builtin <code>isinstance</code>.
Firstly, the <code>bool</code> literals <code>True</code> and <code>False</code> are not deemed to be of type <code>int</code> by <code>is_instance</code>, but they are by the builtin <code>isinstance</code>:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">is_instance</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># builtin</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># builtin</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_instance</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># typing_json</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_instance</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># typing_json</span>
<span class="bp">False</span>
</pre></div>

<p>Secondly, instances of <code>int</code> are deemed to be of type <code>float</code> by <code>is_instance</code>, but they are not by the builtin <code>isinstance</code>:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">is_instance</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># builtin</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="c1"># builtin</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_instance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="c1"># typing_json</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_instance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="c1"># typing_json</span>
<span class="bp">True</span>
</pre></div>

<h2 id="number-types">Number types<a class="headerlink" href="#number-types" title="Permanent link"></a></h2>
<p>When parsing JSON strings, from file object using <code>load</code> or from string instances using <code>loads</code>, the default behaviour is to use the constructor of class <code>Decimal</code> from the builtin <code>decimal</code> library to parse floating point literals.
This informs the following handling of number types in the <code>to_json_obj</code> / <code>from_json_obj</code> functions.</p>
<p>The default behaviour in <code>from_json_obj</code> is to silently decode instances of <code>Decimal</code> to instances of <code>int</code> and <code>float</code>, according to the type specified:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
<span class="mf">1.2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
<span class="mf">1.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>

<p>The optional parameter <code>cast_decimal</code> of <code>from_json_obj</code> (default: <code>True</code>) can be set to <code>False</code> to disable the silent conversion of <code>Decimal</code> to <code>float</code> and <code>int</code>:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="c1"># TypeError: Object Decimal(&#39;1.2&#39;) is not of json basic type t=&lt;class &#39;float&#39;&gt;.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="c1"># TypeError: Object Decimal(&#39;1.0&#39;) is not of json basic type t=&lt;class &#39;float&#39;&gt;.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cast_decimal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="c1"># TypeError: Object Decimal(&#39;1.0&#39;) is not of json basic type t=&lt;class &#39;int&#39;&gt;.</span>
</pre></div>

<p>To ensure that decimal precision is maintained, instances <code>Decimal</code> are always encoded into JSON as strings:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">)</span>
<span class="s">&quot;1.2&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;-16&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">)</span>
<span class="s">&quot;-16&quot;</span>
</pre></div>

<p>The optional parameter <code>use_decimal</code> of <code>to_json_obj</code> (default: <code>True</code>) can be set to <code>True</code> to instead allow instances of <code>Decimal</code> to be used directly in JSON objects:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">use_decimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;-16&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">use_decimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;-16&quot;</span><span class="p">)</span>
</pre></div>

<p>Finally, integers are always silently converted to floating point numbers in <code>from_json_obj</code>, but trying to convert floating point numbers to integers will always raise an error, regardless of whether the encoded number is an integer:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="mf">1.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="mf">1.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="c1"># TypeError: Object 1.0 is not of json basic type t=&lt;class &#39;int&#39;&gt;.</span>
</pre></div>

<h2 id="sequences">Sequences<a class="headerlink" href="#sequences" title="Permanent link"></a></h2>
<p>Instances of <code>List</code>, <code>Tuple</code> and <code>Deque</code> are encoded by <code>to_json_obj</code> as JSON lists, with their elements recursively encoded:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Deque</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;3.5&quot;</span><span class="p">)),</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">&quot;3.5&quot;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">deque</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">]),</span> <span class="n">Deque</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span>
<span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.5&quot;</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">))),</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span>
<span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;0.5&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">]]</span>
</pre></div>

<p>JSON lists are are decoded by <code>from_json_obj</code> to instances of <code>List</code>, <code>Tuple</code> and <code>Deque</code> depending on the specified type, with elements recursively decoded from the elements of the JSON list:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Deque</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">&#39;3.5&#39;</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;3.5&quot;</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">],</span> <span class="n">Deque</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span>
<span class="n">deque</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;0.5&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.5&quot;</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">)))</span>
</pre></div>

<h2 id="sets">Sets<a class="headerlink" href="#sets" title="Permanent link"></a></h2>
<p>Instances of <code>Set</code> and <code>FrozenSet</code> are encoded by <code>to_json_obj</code> as JSON lists, with their elements recursively encoded:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">Set</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.5&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;2.5&quot;</span><span class="p">)}),</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Decimal</span><span class="p">])</span>
<span class="p">[</span><span class="s">&quot;1.5&quot;</span><span class="p">,</span> <span class="s">&quot;2.5&quot;</span><span class="p">]</span>
</pre></div>

<p>JSON lists are are decoded by <code>from_json_obj</code> to instances of <code>Set</code> and <code>FrozenSet</code> depending on the specified type, with elements recursively decoded from the elements of the JSON list:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">Set</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">([</span><span class="s">&quot;1.5&quot;</span><span class="p">,</span> <span class="s">&quot;2.5&quot;</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Decimal</span><span class="p">])</span>
<span class="nb">frozenset</span><span class="p">({</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.5&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;2.5&quot;</span><span class="p">)})</span>
</pre></div>

<h2 id="namedtuples">NamedTuples<a class="headerlink" href="#namedtuples" title="Permanent link"></a></h2>
<p>Instances of typed namedtuples constructed with <code>NamedTuple</code> are encoded by <code>to_json_obj</code> as JSON dictionaries (ordered), with the field names as their keys and the field values recursively encoded:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="o">...</span>     <span class="n">edges</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">&#39;nodes&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="s">&#39;edges&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">(</span><span class="n">to_json_obj</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">Network</span><span class="p">))</span>
<span class="p">{</span><span class="s">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s">&#39;edges&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]}</span>
</pre></div>

<p>JSON dictionaries are decoded by <code>from_json_obj</code> to instances of typed namedtuples depending on the specified type, with fields values recursively decoded from the values of the dictionary:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="o">...</span>     <span class="n">edges</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s">&#39;edges&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]},</span> <span class="n">Network</span><span class="p">)</span>
<span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">edges</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)})</span>
</pre></div>

<p>While <code>collections.OrderedDict</code> is always used by <code>to_json_obj</code> when encoding typed namedtuples, but <code>from_json_obj</code> will also accept ordinary dictionaries (because the order of fields is already determined by the namedtuple type).
If the namedtuple has fields with default values, <code>from_json_obj</code> will use the default value for any field not appearing in the dictionary:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
<span class="o">...</span>     <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&quot;name&quot;</span><span class="p">:</span> <span class="s">&quot;Gill&quot;</span><span class="p">,</span> <span class="s">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">Employee</span><span class="p">)</span>
<span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Gill&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># &quot;id&quot; value from dictionary</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&quot;name&quot;</span><span class="p">:</span> <span class="s">&quot;John&quot;</span><span class="p">},</span> <span class="n">Employee</span><span class="p">)</span>
<span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># default &quot;id&quot; value from `Employee`</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">Employee</span><span class="p">)</span>
<span class="c1"># TypeError: Object {&#39;id&#39;: 0} does not have the required keys:</span>
<span class="c1"># t=&lt;class &#39;__main__.Employee&#39;&gt;, missing keys {&#39;name&#39;}.</span>
</pre></div>

<p>If a field in the namedtuple does not have a default value and does not appear in the dictionary, <code>from_json_obj</code> will raise <code>TypeError</code>.</p>
<h2 id="dictionaries">Dictionaries<a class="headerlink" href="#dictionaries" title="Permanent link"></a></h2>
<p>Instances of <code>Mapping</code> and <code>Dict</code> are encoded by <code>to_json_obj</code> as JSON dictionaries, with their keys and values recursively encoded and their keys stringified if necessary (cf. below).
Instances of <code>OrderedDict</code> follow the exact same rules, but are encoded as instances of <code>collections.OrderedDict</code> rather than instances of <code>dict</code>.</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">collections</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">typing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vect</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">)),</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">))}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span> <span class="s">&quot;0.0&quot;</span><span class="p">],</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;0.0&quot;</span><span class="p">,</span> <span class="s">&quot;1.0&quot;</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span> <span class="s">&quot;0.0&quot;</span><span class="p">],</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;0.0&quot;</span><span class="p">,</span> <span class="s">&quot;1.0&quot;</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">vect</span><span class="p">),</span>
<span class="o">...</span>             <span class="n">typing</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span> <span class="s">&quot;0.0&quot;</span><span class="p">]),</span> <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;0.0&quot;</span><span class="p">,</span> <span class="s">&quot;1.0&quot;</span><span class="p">])])</span>
</pre></div>

<p>Keys are either encoded or encoded and then stringified, depending on the key type:</p>
<ul>
<li>JSON basic types (<code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code> and <code>type(None)</code>) are encoded but not stringified;</li>
<li>literal types are encoded but not stringified (because only JSON basic types are allowed as literals);</li>
<li>enumeration types are encoded but not stringified (because they are already encoded as strings);</li>
<li>all other types are first encoded and then stringified.</li>
</ul>
<p>For example, dictionaries using tuples as keys have their keys first encoded into lists and then stringified to form the keys of the final JSON dictionary:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">({(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="s">&quot;yes&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="s">&quot;no&quot;</span><span class="p">},</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span>
<span class="p">{</span><span class="s">&#39;[0, 1]&#39;</span><span class="p">:</span> <span class="s">&#39;yes&#39;</span><span class="p">,</span> <span class="s">&#39;[2, 3]&#39;</span><span class="p">:</span> <span class="s">&#39;no&#39;</span><span class="p">}</span>
</pre></div>

<p>JSON dictionaries are decoded by <code>from_json_obj</code> to instances of <code>Dict</code> and <code>Mapping</code> depending on the specified type. JSON ordered dictionaries (<code>collections.OrderedDict</code>) are decoded by <code>from_json_obj</code> to instances of <code>Dict</code>, <code>Mapping</code> and <code>OrderedDict</code> depending on the specified type.
Values and keys are recursively decoded, and keys are first de-serialised from strings (using <code>json.loads</code>) if they were stringified as part of the encoding.</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">collections</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">typing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vect_json</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span> <span class="s">&quot;0.0&quot;</span><span class="p">],</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;0.0&quot;</span><span class="p">,</span> <span class="s">&quot;1.0&quot;</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">vect_json</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">)),</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">))}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">vect_json</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">)),</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">))}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">vect_json</span><span class="p">),</span>
<span class="o">...</span>               <span class="n">typing</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]])</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">))),</span> <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;0.0&quot;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">)))])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&#39;[0, 1]&#39;</span><span class="p">:</span> <span class="s">&#39;yes&#39;</span><span class="p">,</span> <span class="s">&#39;[2, 3]&#39;</span><span class="p">:</span> <span class="s">&#39;no&#39;</span><span class="p">},</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="s">&quot;yes&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="s">&quot;no&quot;</span><span class="p">}</span>
</pre></div>

<h2 id="enumerations">Enumerations<a class="headerlink" href="#enumerations" title="Permanent link"></a></h2>
<p>Enumerations members are encoded by using the corresponding member names and decoded by associating the number to the member of corresponding name:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span><span class="p">,</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">RED</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">GREEN</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">BLUE</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span>
<span class="s">&quot;RED&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">(</span><span class="s">&quot;RED&quot;</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">({</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">:</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="o">...</span>              <span class="n">Color</span><span class="o">.</span><span class="n">GREEN</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="o">...</span>              <span class="n">Color</span><span class="o">.</span><span class="n">BLUE</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
<span class="o">...</span>             <span class="n">Dict</span><span class="p">[</span><span class="n">Color</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span>
<span class="p">{</span><span class="s">&#39;RED&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s">&#39;GREEN&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s">&#39;BLUE&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]}</span>
</pre></div>

<h2 id="literal-types">Literal types<a class="headerlink" href="#literal-types" title="Permanent link"></a></h2>
<p>Literal types can be constructed using <code>typing_extensions.Literal</code>, as long as the literals are all of JSON basic type.
Literal types are encoded/decoded exactly like JSON basic types would, i.e. nothing is done to them.</p>
<h2 id="optional-types">Optional types<a class="headerlink" href="#optional-types" title="Permanent link"></a></h2>
<p>When encoding instances of an <code>Optional</code> type, it is first checked whether the instance can be encoded using the given generic type argument. If not, it is checked that the instance is <code>None</code>, in which case <code>None</code> is returned as the encoding (following the procedure for the JSON basic type <code>type(None)</code>).</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">to_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">({</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}},</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span>
<span class="p">{</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_json_obj</span><span class="p">({</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span>
<span class="p">{</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
</pre></div>

<p>Similarly, when decoding instances of an <code>Optional</code> type, it is first checked whether the JSON object can be decoded using the given generic type argument. If not, it is checked that the instance is <code>None</code>, in which case <code>None</code> is returned as the decoding.</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">from_json_obj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span>
<span class="p">{</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">from_json_obj</span><span class="p">({</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span>
<span class="p">{</span><span class="s">&quot;set&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
</pre></div>

<h2 id="union-types">Union types<a class="headerlink" href="#union-types" title="Permanent link"></a></h2>
<p>When serialising instances <code>obj</code> of a <code>Union</code> type, the generic type arguments of <code>Union</code> are tried in sequence until a type <code>T</code> is found of which <code>obj</code> is an instance (accoring to the <code>is_instance</code> function).
The serialisation then proceeds using <code>T</code> as the static type:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">dumps</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `dumps(1, int)`</span>
<span class="s">&#39;1&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `dumps(&quot;hello&quot;, str)`</span>
<span class="s">&#39;&quot;hello&quot;&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `dumps(2.5, float)`</span>
<span class="s">&#39;2.5&#39;</span>
</pre></div>

<p>When the JSON data <code>obj_json</code> is de-serialised, the generic type arugments of <code>Union</code> ara again tried in sequence until a type <code>T</code> is found which results in correct de-serialisation of <code>obj_json</code>:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `loads(1, int)`</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="s">&#39;&quot;hello&quot;&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `loads(&quot;hello&quot;, str)`</span>
<span class="s">&quot;hello&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="s">&#39;2.5&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="c1"># same as `loads(2.5, float)`</span>
<span class="mf">2.5</span>
</pre></div>

<p>This works well as long as the JSON encodings of the types are disjoint, as is the case for all JSON basic types.
Unfortunately, some issues arise with overlapping union types, explained more in detail below.
In short: if two types in a <code>Union</code> have overlapping JSON encodings (e.g. <code>List</code> and <code>Set</code> are both encoded into JSON using lists), they may be deserialised to the incorrect runtime type (though the static <code>Union</code> type will still be respected).</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Union</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">dumps</span><span class="p">,</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">UnionT</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">UnionT</span><span class="p">)</span>
<span class="s">&#39;[1, 2, 3]&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dumps</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">UnionT</span><span class="p">)</span>
<span class="s">&#39;[1, 2, 3]&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">UnionT</span><span class="p">),</span> <span class="n">UnionT</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">UnionT</span><span class="p">),</span> <span class="n">UnionT</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>

<p>Tagged unions can be used to mitigate this issue. Currently, tagged unions need to be defined manually (cf. below), but an automated way to construct them is a planned feature for future versions.</p>
<h2 id="overlapping-union-types">Overlapping union types<a class="headerlink" href="#overlapping-union-types" title="Permanent link"></a></h2>
<p>However, this may create some issues when the following conditions are met:</p>
<ol>
<li>the JSON encodings for two type in the <code>Union</code> overlap, as is the case for the collections <code>List</code>, <code>Tuple</code>, <code>Deque</code>, <code>Set</code> and <code>FrozenSet</code>;</li>
<li>the application depends on the runtime type of the <code>Union</code> instances in a way which results in incompatible behaviour on the overlaps.</li>
</ol>
<p>The de-serialised object is still going to be a valid instance of the <code>Union</code> type, but its runtime type may not be the expected one.
To see a concrete example of this, imagine that we have a network with nodes labelled by <code>int</code>, featuring both directed and undirected edges.
The directed edges are encoded as 2-tuples, while the undirected edges are encoded as frozensets with two elements.
Let&rsquo;s look at what happens when we serialise and de-serialise such a network:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">dumps</span><span class="p">,</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="o">...</span>     <span class="n">edges</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">})}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
<span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">edges</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network_serialised</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network_serialised</span><span class="p">)</span>
<span class="p">{</span><span class="s">&quot;nodes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network_deserialised</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">network_serialised</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network_deserialised</span><span class="p">)</span>
<span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">edges</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)})</span>
</pre></div>

<p>Both directed edges (instances of <code>Tuple[int, int]</code>) and undirected edges (instances of <code>FrozenSet[int]</code> with two elements) in our <code>Network</code> data structure are encoded as lists with two elements.
For example, <code>[1, 3]</code> is the encoding of both the undirected edge <code>frozenset({1, 3})</code> (which is in our network) and a directed edge <code>(1, 3)</code> (which is not in our network).
Because of this, <code>[1, 3]</code> can be deserialised using both <code>Tuple[int, int]</code> and <code>FrozenSet[int]</code>: since <code>Tuple[int, int]</code> appears first in the list of generic type arguments to <code>Union</code>, <code>[1, 3]</code> will be deserialised to a directed edge <code>(1, 3)</code>, even though it was serialised from an undirected edge <code>frozenset({1, 3})</code>.
Indeed, you can see from the prints of the example above that our original network had one directed edge <code>(1, 2)</code> and two undirected edges <code>frozenset({1, 3})</code> and <code>frozenset({2, 3})</code>, while the network we de-serialised has three directed edges <code>(1, 2)</code>, <code>(1, 2)</code> and <code>(2, 3)</code> and no undirected edges.</p>
<p>A way to solve this issue is to use a tagged union instead of the original union:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">typing_json</span> <span class="kn">import</span> <span class="n">dumps</span><span class="p">,</span> <span class="n">loads</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">DirEdgeT</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">UndirEdgeT</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s">&quot;u&quot;</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="o">...</span>     <span class="n">edges</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">DirEdgeT</span><span class="p">,</span> <span class="n">UndirEdgeT</span><span class="p">]]</span>
<span class="o">...</span>     <span class="nd">@staticmethod</span>
<span class="o">...</span>     <span class="k">def</span> <span class="nf">from_untagged</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
<span class="o">...</span>                       <span class="n">edges</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">tagged_edges</span> <span class="o">=</span> <span class="p">{(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">}</span>
<span class="o">...</span>         <span class="k">return</span> <span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">tagged_edges</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>

<p>The factory method <code>from_untagged</code> is there to allow automated tagging of edges as directed/undirected based on their runtime type: it is not used when de-serialising the network objects from JSON.
Because the union is tagged, the edges are now de-serialised to the correct runtime type:</p>
<div class="codehilite"><pre><span class="c1"># Python 3.7.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">})}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="n">from_untagged</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
<span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="n">edges</span><span class="o">=</span><span class="p">{(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">})),</span> <span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network_serialised</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network_serialised</span><span class="p">)</span>
<span class="p">{</span><span class="s">&quot;nodes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">network_deserialised</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">network_serialised</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">network_deserialised</span><span class="p">)</span>
<span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="n">edges</span><span class="o">=</span><span class="p">{(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">})),</span> <span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))})</span>
</pre></div></article></body></html>